# -*- coding: utf-8 -*-
"""Parse 3P XML (.jwgbt) output files.
TODO The 3P jwgbt format does not appear to contain uptake data. Instead it
appears to contain information about the pressure and temperature of each dose.
While theoretically, the amount adsorbed could be calculated from this data, it
is outside the scope of a pure parser implementation. See below available data.

<Adsorb>
    <Item ID="0" Pd="-0.0000100000000000" Pcd="0.0663320194291271"
    PdT="0.0000000000000000" PcdT="26.1712062256809332" Day="2022-07-06"
    Time="11:32:03" P0="102.7410188143739873" Balance="1" SubIndex="0"/>
    <Item ID="1_1" Pd="2.2583126573586632" Pcd="0.0909305451248286"
    PdT="26.1886015106431671" PcdT="26.1886015106431671" Day="2022-07-06"
    Time="11:33:50" P0="102.7308462348363349" Balance="0" SubIndex="1"/>
    ...
</Adsorb>

The current parser version will be left here for the time being, in case the
uptake is added in a latter manufacturer format change.
"""

import xml.etree.ElementTree as ET

_DATA_DICT = {
    'measurement': {
        'text': ('ID', ),
    },
    'pressure': {
        'text': ('Pd', ),
    },
    'reference_temperature': {
        'text': ('PcdT', ),
    },
    'cell_temperature': {
        'text': ('PcdT', ),
    },
    'pressure_saturation': {
        'text': ('P0', ),
    },
    'pressure_relative': {
        'text': ('p/p0', ),
    },
    'experiment_time': {
        'text': ('Time', ),
    },
    'experiment_date': {
        'text': ('Day', ),
    },
}


def parse(path):
    """
    Parse an XML file generated by 3P software.

    Parameters
    ----------
    path: str
        The location of an XML file generated by a 3P instrument.

    Returns
    -------
    meta : dict
        Isotherm metadata.
    data : dict
        Isotherm data.
    """
    meta = {}
    data = {}

    # parse the XML file
    tree = ET.parse(path)
    root = tree.getroot()

    # Metadata
    meta_raw = {}
    general_config = root.find('General').find('GeneralConfig')
    meta_raw["adsorbate"] = general_config.find('AdsorbGas')
    meta_raw["temperature"] = general_config.find('AdsorbTemp')
    meta_raw['temperature_unit'] = 'K'

    station_config = root.find('StationConfig').find('Station')
    meta_raw['instrument'] = station_config.find('Name')
    meta_raw['instrument_model'] = station_config.find('Model')

    config_base = root.find('Config').find('Base')
    meta_raw['date'] = config_base.find('StartTime')
    meta_raw['date_finished'] = config_base.find('CompletedTime')

    config_sample = root.find('Config').find('SampleInfo')
    meta_raw['material'] = config_sample.find('SampleName')
    meta_raw['sample'] = config_sample.find('SampleNum')
    meta_raw['_adsnt_degas_summary'] = config_sample.find('DegasCondition')
    meta_raw['_adsnt_sample_mass'] = config_sample.find('SampleWeight')
    meta_raw['_exptl_operator'] = config_sample.find('Operator')

    # Data
    data_element = root.find('Data').find('Adsorb')
    data = _parse_header(data_element)
    data = _parse_data(data_element, data)
    data_element = root.find('Data').find('Doff')
    data = _parse_data(data_element, data)
    # data needs trimming and conversions
    data = _process_data(data)
    # Check data integrity (parser-specific)
    _check(meta, data, path)

    # Set extra metadata
    meta['apparatus'] = '3P'

    return meta, data


def _parse_header(sorp_xml_node) -> dict[str:list]:
    """Parse one of the XML points's attributes to get data headers."""
    headers = {'branch': []}
    attribs = sorp_xml_node[0].attrib.keys()
    for attrib in attribs:
        headers[attrib] = []
    return headers


def _parse_data(data_element, data_dict) -> dict[str:list]:
    """Parse all XML children in a node sequentially and their attributes as data."""
    for point in data_element.findall('Item'):
        for key, val in point.attrib.items():
            data_dict[key].append(val)
    return data_dict


def _process_data(data_dict):

    # data does not contain incremental amount adsorbed

    return data_dict


def _check(meta, data, path):
    """
    Check keys in data and logs a warning if a key is empty.

    Also logs a warning for errors found in file.
    """
